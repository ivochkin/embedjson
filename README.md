# embedjson
[![License MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/ivochkin/embedjson/master/LICENSE)
[![Build Status](https://travis-ci.org/ivochkin/embedjson.svg?branch=master)](https://travis-ci.org/ivochkin/embedjson)
[![codecov.io](https://codecov.io/github/ivochkin/embedjson/coverage.svg?branch=master)](https://codecov.io/github/ivochkin/embedjson?branch=master)

SAX-style JSON parser, a component of jcppy code generator (https://github.com/ivochkin/jcppy)

## Disclaimer

If you are looking for a generic JSON parser/emitter, you are in the wrong place.

Embedjson is __not__ a general purpose JSON library, it is designed to be embedded into the
C/C++ object files generated by [jcppy](https://github.com/ivochkin/jcppy) to handle specific
case of JSON parsing when document structure is known (completely, or partically, as defined
by JSON Schema). In the case, JSON parsing can be optimized by throwing away code branches
that will be never reached due to the restricting document schema.

Take a look at those brilliant projects if you need a generic JSON library:
* https://github.com/lloyd/yajl
* https://github.com/miloyip/rapidjson

## Features

* No dependencies. Even libc is not needed
* No memory allocations. Embedjson can be configured to use externally managed dynamic stack
* UTF-8 validation, including [UTF-8 Shortest Form](http://www.unicode.org/versions/corrigendum1.html)

## Configuring embedjson

A set of `#define` directives can be specified *before* inlining embedjson.c
into the code to configure it:

| Name                        | Default   | Description
|:--------------------------- |:--------- |:--------------------------------
| EMBEDJSON_DYNAMIC_STACK     | 0         | Define to enable dynamic stack to hold parser's state. When dynamic stack is enabled, user is responsible for initializing `embedjson_parser.stack` and `embedjson_parser.stack_size` properties . By default static stack of the fixed size is used.<br/>Note: when EMBEDJSON_DYNAMIC_STACK is enabled, one have to provide `embedjson_stack_overflow` function implementation in addition to regular parsing events handlers.
| EMBEDJSON_STATIC_STACK_SIZE | 16        | Size (in bytes) of the stack. Size of the stack determines maximum supported objects/arrays nesting level.
| EMBEDJSON_VALIDATE_UTF8     | 1         | Enable UTF-8 validation
| EMBEDJSON_SIZE_T            | guessed   | A type to use where `size_t` is needed. By default, `unsigned long` or `unsigned long long` are used, depending on the target architecture

## Usage guide

Run `scripts/amalgamate.sh` to generate `embedjson.c`.
Inline `embedjson.c` into your code and provide an implementation for the following functions:

* `int embedjson_error(struct embedjson_parser* parser, const char* position);`
* `int embedjson_null(embedjson_parser* parser);`
* `int embedjson_bool(embedjson_parser* parser, char value);`
* `int embedjson_int(embedjson_parser* parser, long long value);`
* `int embedjson_double(embedjson_parser* parser, double value);`
* `int embedjson_string_begin(embedjson_parser* parser);`
* `int embedjson_string_chunk(embedjson_parser* parser, const char* data, embedjson_size_t size);`
* `int embedjson_string_end(embedjson_parser* parser);`
* `int embedjson_object_begin(embedjson_parser* parser);`
* `int embedjson_object_end(embedjson_parser* parser);`
* `int embedjson_array_begin(embedjson_parser* parser);`
* `int embedjson_array_end(embedjson_parser* parser);`
* `int embedjson_stack_overflow(embedjson_parser* parser);` (Only if `EMBEDJSON_DYNAMIC_STACK` is enabled)

Finally you'll end up with a source file similar to this:

```c
// json_document_verifier.c
#include <string.h> /* for memset */

#define EMBEDJSON_DYNAMIC_STACK 0
#include <embedjson.c>

static int embedjson_error(struct embedjson_parser* parser, const char* position)
{
  return 1;
}
static int embedjson_null(embedjson_parser* parser)
{
  // Place here the code that handles incoming "null" value.
  // The same logic applies to other embedjson_* functions as well.
  return 0;
}
static int embedjson_bool(embedjson_parser* parser, char value) { return 0; }
static int embedjson_int(embedjson_parser* parser, long long value) { return 0; }
static int embedjson_double(embedjson_parser* parser, double value) { return 0; }
static int embedjson_string_begin(embedjson_parser* parser) { return 0; }
static int embedjson_string_chunk(embedjson_parser* parser,
    const char* data, embedjson_size_t size) { return 0; }
static int embedjson_string_end(embedjson_parser* parser) { return 0; }
static int embedjson_object_begin(embedjson_parser* parser) { return 0; }
static int embedjson_object_end(embedjson_parser* parser) { return 0; }
static int embedjson_array_begin(embedjson_parser* parser) { return 0; }
static int embedjson_array_end(embedjson_parser* parser) { return 0; }

int main()
{
  char json[] = "{\"some\": \"json\", \"object\": true}";
  embedjson_parser parser;
  memset(&parser, 0, sizeof(parser));
  return embedjson_push(&parser, json, sizeof(json) - 1);
}
```

One more example of how to intergrate embedjson into the application can be found in `embedjson_parse.c`.

## TODO
- Error handling
- UTF-16, UTF-32 support
- bignums (integers with values above 64 bits)
